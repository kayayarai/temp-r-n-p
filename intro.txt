---
title: "Roles and Profiles: Introduction"
---

[module]: TODO
[class]: TODO
[environment.conf]: TODO
[hiera]: TODO
[puppet lookup]: TODO
[auto_params]: TODO
[lookup_function]: TODO
[main manifest]: TODO
[resource-like]: TODO
[rtyler/jenkins]: TODO
[puppetlabs/apt]: TODO


Most people's primary goal with Puppet is to build _complete system configurations:_ that is, to manage all of the software, services, and configuration they care about on a given system. (This usually isn't _every_ piece of software on a system; just the subset that matters to your business.)

Building system configurations can be difficult --- mostly because the systems you manage are complicated. To keep that complexity under control, your code needs to be reusable, easy to configure, and easy to refactor.

The **roles and profiles** method is Puppet's best tool for building reusable, configurable, and refactorable system configurations. It's not a straightforward recipe: you must think hard about the nature of your infrastructure and your team. It's also not a final state: expect to refine your configurations over time. Instead, it's an approach to _designing your infrastructure's interface_ --- sealing away incidental complexity, surfacing the significant complexity, and making sure your data behaves predictably.

## The roles and profiles architecture

Roles and profiles are **two extra layers of indirection** between your node classifier and your component modules.

> **Note:** A component module is a normal module that manages one technology. See the [glossary][] below.

![Diagram: NC assigns one role to group of nodes; role declares several profiles; profiles declare resources and classes from component modules, as well as core resources and other profiles.](./roles_and_profiles_overview.jpg)

In short, from top to bottom:

* Your node classifier assigns one **role** class to a group of nodes. The role manages a whole system configuration, so no other classes are needed. The NC does not configure the role in any way.
* That role class declares some **profile** classes with `include`, and does nothing else. For example:

  ``` puppet
  class role::jenkins::master {
    include profile::base
    include profile::server
    include profile::jenkins::master
  }
  ```

* Each profile configures a layered technology stack, using multiple component modules and the built-in resource types. (In the diagram, `profile::jenkins::master` uses [rtyler/jenkins][], [puppetlabs/apt][], a home-built backup module, and some `package` and `file` resources.)
* Profiles can take configuration data from Hiera or Puppet lookup.
* You limit your use of component module classes as follows:
    * Component classes are always declared via a profile, and never assigned directly to a node.
    * If they have class parameters, you specify them in the profile; never use Hiera or Puppet lookup to override component class params.

These extra layers of indirection might seem like they add complexity, but what they really do is give you a space to build practical, business-specific interfaces to the differences you care most about. A better interface makes hierarchical data easier to use, makes system configurations easier to read, and makes refactoring easier.

### Building configurations without roles and profiles

Without roles and profiles, people typically build system configurations in their node classifier or [main manifest][], using Hiera to handle tricky inheritance problems. A standard approach is to create a group of similar nodes and assign classes to it, then create child groups with extra classes for nodes that have additional needs. Another common pattern is to put everything in Hiera, using a very large hierarchy that reflects every variation in the infrastructure.

If this works for you, then it works! You might not need roles and profiles. But most people find direct building gets difficult to understand and maintain over time.

## Glossary of terms

[glossary]: #glossary-of-terms

* **Node classifier:** A tool that assigns classes to nodes. Generally means the Puppet Enterprise console, but can also be the [main manifest][] or Hiera.
* **Component module:** A normal module that manages one particular technology. They're usually named after the software they manage (puppetlabs-apache, etc.), and are often written by third parties and published on the Puppet Forge.

    In general, component modules are highly configurable, especially Forge modules that must serve a wide variety of people and needs. Their classes tend to have a lot of parameters.
* **Profile:** A business-specific wrapper class that configures a layered technology stack (which might involve several pieces of software). They usually take advantage of classes and resources from several different component modules.

    Profiles should have only a small amount of configuration, since they're already written to support your particular needs.

    Profile classes should all be stored in one module, named `profile`.
* **Role:** A business-specific wrapper class that builds a complete system configuration by declaring one or more profiles.

    Roles should have no configuration. They should all be stored in a single module, named `role`.


## Guiding principles

As you write profiles, you'll make a lot of challenging decisions about how to organize code and data. When faced with something sticky, remember these principles:

### Data is only for profiles

Node-specific config data should only enter the system at _one place:_ your profiles. Don't use Hiera to configure component classes; don't use it to configure roles.

* Restricting data like this makes it easier for your ops team to work together on shared code. Everybody who uses your profiles knows exactly how to configure them, which saves time and reduces errors.
* It also makes it easier to refactor your profiles, or adapt them to new versions of upstream component modules.

### Keep profiles `include`-safe

Your profile classes must work safely with the `include` function. This means:

* You must never use [resource-like declarations][resource-like] on profiles.
* Profiles can specify class parameters, but they must get their values from Hiera / Puppet lookup. We also recommend setting default values.

**This is the keystone to making roles and profiles work well at your business.** It lets you combine profiles freely to build system configurations, while allowing profiles to pull in other profiles as needed.

### Sometimes repetition is the cost of clarity

You'll sometimes have to decide between repeating yourself (making code easier to read and understand, but potentially more difficult to refactor) or splitting code into more pieces (making it simpler and easier to refactor, but more difficult to read and understand). This mostly comes up when working with roles, or with super-profiles that include several other profiles.

There's not necessarily a right answer to this trade-off, because it depends on what your business values most. Think hard about what you and your team find most difficult.

